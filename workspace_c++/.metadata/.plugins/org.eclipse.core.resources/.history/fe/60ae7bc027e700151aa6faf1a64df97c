/*
 * arcabook_republisher.cpp
 *
 *  Created on: Mar 25, 2011
 *      Author: bill
 */


#include <amm/comm/impl/msgs.hpp>
#include <amm/comm/impl/defs_poco.hpp>
#include <amm/comm/impl/config.hpp>
#include <amm/comm/impl/communicatorhandlepubsub.hpp>
#include <amm/comm/impl/communicator.hpp>
#include <amm/comm/impl/ieventhandler.hpp>
#include <amm/comm/impl/defs.hpp>
#include <amm/comm/impl/defs_poco.hpp>
#include <amm/comm/impl/config.hpp>
#include <amm/comm/impl/ieventhandler.hpp>
#include <amm/comm/impl/ieventhandlerpubsub.hpp>
#include <amm/comm/communicator.hpp>
#include <amm/comm/impl/communicator.hpp>
#include <amm/comm/interfaces.hpp>
#include <amm/comm/publisher.hpp>
#include <amm/comm/impl/communicatorhandlepubsub.hpp>
#include <amm/comm/impl/defs.hpp>
#include <amm/comm/subscriber.hpp>
#include <amm/core/blocking_queue.hpp>
#include <amm/data/trade_msgs.hpp>
#include <amm/data/cme_msg.hpp>
#include <amm/data/quote_msg.hpp>
#include <amm/data/status_updater.hpp>
#include <amm/fom/amm_component.hpp>
#include <amm/fom/security.hpp>
#include <amm/fom/security_registry.hpp>
#include <amm/marketfeeds/feed_publisher.hpp>
#include <amm/posix/thread_local.hpp>
#include <amm/posix/thread.hpp>
#include <amm/quant/messages.hpp>
#include <amm/quant/message_type.hpp>

#include <amm/data/headerinfo.hpp>
#include <amm/data/field.hpp>
#include <amm/data/cme_msg.hpp>
#include <amm/comm/impl/defs_poco.hpp>
#include <amm/comm/impl/config.hpp>

#include <amm/comm/impl/communicatorhandlepubsub.hpp>
#include <amm/comm/impl/communicator.hpp>
#include <amm/comm/impl/ieventhandler.hpp>
#include <amm/comm/impl/defs.hpp>
#include <amm/poco/configuration.hpp>

#include <Poco/Util/XMLConfiguration.h>
#include <Poco/AutoPtr.h>
#include <Poco/Mutex.h>

#include <iomanip>
#include <memory>
#include <stdlib.h>

bool global_debug;

class Listener : public amm::comm::IEventHandler, public amm::comm::IEventHandlerPubSub {
public:
    Listener(amm::comm::Communicator& theCommunicator, Poco::FastMutex& fastMutex, std::map< amm::fom::SecurityIDType, uint64_t >& lastUpdateMap,
    std::map< amm::fom::SecurityIDType, amm::comm::StockOrderBook* >& sobMap)
		: _communicator(theCommunicator),
		  _fastMutex(fastMutex),
		  _lastUpdateMap(lastUpdateMap),
		  _sobMap(sobMap) {
    }

    ~Listener() {};

    // IEventHandler interface
    //
    virtual const std::string& name() const { return _ourName; }

    virtual void onAlert(amm::comm::t_comm_key theKey, const amm::core::AlertInfo& theAlertInfo) {
        AMM_LOG_WARNING << theKey << "::" << theAlertInfo.myType << "::" << theAlertInfo.myAlert << std::endl;
    }

    virtual void onError(amm::comm::t_comm_key theKey, const amm::core::ErrorInfo& theErrorInfo) {
        AMM_LOG_ERROR << theKey << "::" << theErrorInfo.myType << "::" << theErrorInfo.myError << std::endl;
    }

    virtual void onTimeout() {
       throw("Shouldn't be called!!!!");
    }

    virtual size_t onData(amm::comm::t_comm_key theKey, const char* theBuffer, size_t theLength, amm::Time theRecvTime) {
    	Poco::FastMutex::ScopedLock lock(_fastMutex);
    	_sobTmp = reinterpret_cast< const amm::comm::StockOrderBook* >(theBuffer);
    	if(_sobMap.find(_sobTmp->myAMMInstrumentID.get()) != _sobMap.end()) {
    		_sob = _sobMap[_sobTmp->myAMMInstrumentID.get()];
    		_lastUpdateMap[_sobTmp->myAMMInstrumentID.get()] = amm::Time::now().usec();
    		memcpy(_sob, _sobTmp, sizeof(amm::comm::StockOrderBook));
    	}
    	return theLength;
    }

    // IEventHandlerPubSub interface
    //
    virtual void onCommunicatorCreation(const amm::comm::t_comm_key& theKey, amm::comm::CommunicatorHandlePubSubPtr& theCommunicatorHandle) {
        _key = theKey;
        _communicatorHandle = theCommunicatorHandle;

        amm::comm::IEventHandlerPtr aThis(this, true);
        _communicatorHandle->start(this->name(), aThis);
    }

    void stop() {
        if ( 0 < _key && NULL != _communicatorHandle ) {
            _communicator.unregisterPubSub(_key);
            _key = 0;
            _communicatorHandle = NULL;
        }
    }

public:
    amm::comm::Communicator& _communicator;
    amm::comm::t_comm_key _key;
    amm::comm::CommunicatorHandlePubSubPtr _communicatorHandle;
    std::string _ourName;
    Poco::FastMutex& _fastMutex;
    std::map< amm::fom::SecurityIDType, uint64_t >& _lastUpdateMap;
    std::map< amm::fom::SecurityIDType, amm::comm::StockOrderBook* >& _sobMap;
    const amm::comm::StockOrderBook *_sobTmp;
    amm::comm::StockOrderBook *_sob;
};

class DoRepublish {
public:
	DoRepublish(Poco::FastMutex& fastMutex, std::map< amm::fom::SecurityIDType, uint64_t >& lastUpdateMap,
		    std::map< amm::fom::SecurityIDType, amm::comm::StockOrderBook* >& sobMap, uint64_t repub_freq) : _fastMutex(fastMutex),
		    _lastUpdateMap(lastUpdateMap),
		    _sobMap(sobMap),
		    _repub_freq(repub_freq) {}
	~DoRepublish() {};
	void init(amm::poco::Configuration& cfg) {
		std::string comm_config_xml = cfg.getString("Network.comm_file");
		Poco::AutoPtr<Poco::Util::AbstractConfiguration> config;
		config.assign(new Poco::Util::XMLConfiguration(comm_config_xml));
		_communicator.start(config);
		_topicResolver.load(comm_config_xml);
		_handler.assign(new amm::marketfeeds::MCPublisher(_communicator));
		((amm::marketfeeds::MCPublisher*)_handler.get())->name("ARCAPublisher");
	    _topic.myTopicEnv = ::amm::comm::eTopicEnv::parse(cfg.getString("MarketData.ARCA[@env]"));
	    _topic.myTopicGroupName = cfg.getString("MarketData.ARCA[@group_name]");
	    _topic.myTopicName = cfg.getString("MarketData.ARCA[@name]");
	    if ( _topicResolver.getTopicInfo(_topic, _topicIpInfo) ) {
	    	std::cout << "Topic: " << _topic.toString() << " -- has IP params: " << _topicIpInfo.toString() << std::endl;
	    } else {
	    	std::cerr << "Topic: " << _topic.toString() << " -- failed to find IP params!" << std::endl;
	    }
	    _communicator.registerPubSub(_topicIpInfo, _handler);
	}
	void run();


	// test
private:
	amm::comm::ConfigTopic _topic;
	amm::comm::ConfigCommPubSub _topicIpInfo;
	amm::comm::Communicator _communicator;
	amm::comm::IEventHandlerPubSubPtr _handler;
	amm::comm::ConfigCommTopicGroups _topicResolver;
	Poco::FastMutex& _fastMutex;
	std::map< amm::fom::SecurityIDType, uint64_t >& _lastUpdateMap;
	std::map< amm::fom::SecurityIDType, uint64_t >::iterator _itrS;
	std::map< amm::fom::SecurityIDType, uint64_t >::iterator _itrE;
	std::map< amm::fom::SecurityIDType, amm::comm::StockOrderBook* >& _sobMap;
	uint64_t _repub_freq;
};

void DoRepublish::run() {
	uint64_t time_now;
	amm::fom::SecurityRegistry& secReg = amm::fom::SecurityRegistry::instance();
	const amm::fom::Stock *stock;
	while(true) {
		{
			Poco::FastMutex::ScopedLock lock(_fastMutex);
			_itrS = _lastUpdateMap.begin();
			_itrE = _lastUpdateMap.end();
			time_now = amm::Time::now().usec();
			while(_itrS != _itrE) {
				if(time_now - _itrS->second > _repub_freq) { // stale data from exchange, republish the last update
					stock = secReg.getStockById(_itrS->first);
					if(global_debug == true)
						std::cout << "Repub," << amm::Time::now() << ",last," << amm::Time(_itrS->second) << ","
						<< _sobMap[_itrS->first]->myAMMInstrumentID.get() << "," << stock->amm_instrument_id << "," << stock->symbol << ","
						<< _sobMap[_itrS->first]->myBidSize1.get() << "," << _sobMap[_itrS->first]->myBidPrice1.get() << " : "
						<< _sobMap[_itrS->first]->myAskPrice1.get() << "," << _sobMap[_itrS->first]->myAskSize1.get() << std::endl;
					((amm::marketfeeds::MCPublisher*)_handler.get())->send((const char*)_sobMap[_itrS->first],sizeof(amm::comm::StockOrderBook));
				}
				_itrS++;
			}
			std::cout << std::endl;
		}
		usleep(_repub_freq);
	}
}

void usage() {
	std::cout << "arcabook_republisher -c /opt/amm/generic_conf.ammprod.xml -i 5" << std::endl;
}

int main(int argc, char* argv[]) {
    int32_t opt;
    std::string configFile;
    int interval;
    global_debug = false;
    while ( -1 != ( opt = ::getopt(argc, argv, "c:i:d") ) ) {
        switch ( opt ) {
            case 'c':
                configFile = optarg;
                break;
            case 'i':
            	interval = atoi(optarg);
            	break;
            case 'd':
            	global_debug = true;
            	break;
            case '?':
            	usage();
            	break;
        }
    }

    std::auto_ptr<Listener> arcabookListener;
    amm::comm::Communicator communicator;
    amm::comm::ConfigTopic arcabookTopic;

    Poco::FastMutex fastMutex;
    std::map< amm::fom::SecurityIDType, uint64_t > lastUpdateMap;
    std::map< amm::fom::SecurityIDType, amm::comm::StockOrderBook* > sobMap;
    const amm::fom::Stock *stock;
    amm::comm::StockOrderBook *sob;

    amm::poco::Configuration config(new Poco::Util::XMLConfiguration(configFile));
    std::string underlyersFile = config.getString("RetrieveSecurityData.underliers_file");
    std::string	optionsFile = config.getString("RetrieveSecurityData.options_file");
    std::string	dividendsFile = config.getString("RetrieveSecurityData.dividends_file");
    amm::fom::SecurityRegistry& secReg = amm::fom::SecurityRegistry::instance();
    secReg.load(underlyersFile,optionsFile,dividendsFile);

	std::list<std::string> stocks;
	secReg.getStocksList(&stocks);
	stocks.sort();
	std::list<std::string>::iterator iter = stocks.begin();
	std::list<std::string>::iterator end = stocks.end();
	while(iter != end) {
		stock = secReg.getStockBySymbol(*iter);
		lastUpdateMap[stock->amm_instrument_id] = amm::Time::now().usec();
		sob = new amm::comm::StockOrderBook;
		sobMap[stock->amm_instrument_id] = sob;
		iter++;
	}

	// republish every 5 seconds if stale
	DoRepublish republisher(fastMutex, lastUpdateMap, sobMap, 3000000);
    republisher.init(config);

    amm::comm::ConfigCommPubSub topicIpInfo;
    amm::comm::ConfigCommTopicGroups topicResolver;
    Poco::AutoPtr<Poco::Util::AbstractConfiguration> commConfig;
    std::string	commConfigFile = config.getString("Network.comm_file");
    commConfig.assign(new Poco::Util::XMLConfiguration(commConfigFile));
    communicator.start(commConfig);
    topicResolver.load(commConfigFile);

    // register handler to get Arcabook
    arcabookListener.reset(new Listener(communicator, fastMutex, lastUpdateMap, sobMap));
    amm::comm::IEventHandlerPubSubPtr arcabookHandler(arcabookListener.get(), true);
    arcabookTopic.myTopicEnv = ::amm::comm::eTopicEnv::parse(config.getString("MarketData.ARCA[@env]"));
    arcabookTopic.myTopicGroupName = config.getString("MarketData.ARCA[@group_name]");
    arcabookTopic.myTopicName = config.getString("MarketData.ARCA[@name]");
    if ( topicResolver.getTopicInfo(arcabookTopic, topicIpInfo) ) {
    	std::cout << "Topic: " << arcabookTopic.toString() << " -- has IP params: " << topicIpInfo.toString() << std::endl;
    } else {
    	std::cerr << "Topic: " << arcabookTopic.toString() << " -- failed to find IP params!" << std::endl;
    }
    communicator.registerPubSub(topicIpInfo, arcabookHandler);

    amm::posix::Thread tPublisher = amm::posix::Thread::make(amm::DelegateV0(&republisher, &DoRepublish::run));

    // send status updates
	amm::data::StatusUpdater statusUpdater(config);
	statusUpdater.setFreq(30);
	statusUpdater.setCompType(amm::fom::AMMComponentType::ARCARePub);
	statusUpdater.setInstanceID(1);
	statusUpdater.setInstanceName("ArcaRePub");
	amm::posix::Thread tStatus = amm::posix::Thread::make(amm::DelegateV0(&statusUpdater, &amm::data::StatusUpdater::run));

    communicator.process_forever();

    return 0;
}

