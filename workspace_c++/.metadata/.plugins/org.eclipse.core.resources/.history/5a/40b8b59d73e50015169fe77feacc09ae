/*
 * Inherited.h
 *
 *  Created on: Mar 8, 2016
 *      Author: bill
 */

#ifndef INHERITED_H_
#define INHERITED_H_
#include "Incls.h"

namespace Inherited {

class Inherited {
public:
	Inherited();
	virtual ~Inherited();
};

class B {
public:
	void f_pub() { std::cout << "f_pub is called" << std::endl; }
protected:
	void f_prot() { std::cout << "f_prot is called" << std::endl; }
private:
	void f_priv() { std::cout << "f_priv is called" << std::endl; }

};

class D_priv : private B {
public:
	void f(){
		f_pub(); // ok, D_priv's private function
		f_prot(); // ok, D_priv's private function
		//f_priv(); // error
	}
};
class D_prot : protected B {
public:
	using B::f_pub;
	void f(){
		f_pub(); // ok, D_pub's protected function
		f_prot(); // ok, D_pub's protected function
		//f_priv(); // error
	}

};
class D_pub : public B {
public:
	void f(){
		f_pub(); // ok, D_pub's public function
		f_prot(); // ok, D_pub's protected function
		//f_priv(); // error
	}
};

/*
 * Access Control:
 * 1. None of the derived classes can access anything that is private in B.
 * 2. D_pub inherits public members of B as public and the protected members of B as protected
 * 3. D_priv inherits the public and protected members of B as private
 * 4. D_prot inherits the public and protected members of B as protected
 * Casting:
 * 1. Anyone can cast a D_pub* to B*. D_pub is a special kind of B.
 * 2. D_priv's members and friends can cast a D_priv* to B*
 * 3. D_prot's members, friends, and children can cast a D_prot* to B*
 */

/*
 * public inheritance: is-a relation, eg, D_pub is-a kind of B
 * private inheritance: similar to has-a relation
 */

class ring {
public:
	void tinkle() { std::cout << "Ring tinkle...\n"; }
};

/* composition */
class dog {
	ring m_ring;
public:
	void tinkle() { m_ring.tinkle(); } // call forwarding
};

/* private inheritance */
class dog2 : private ring {
public:
	using ring::tinkle;
};
/* composition preferred over private inheritance */

class bird {
};

class flayablebird : public bird {
public:
	void fly();
};

class penguin : public bird {};
} /* namespace Inherited */

namespace InheritedII {
class dog{
	std::string m_name;
public:
	dog() { std::cout << "A dog is born.\n"; };
	dog(std::string name) : m_name(name) {
		std::cout << m_name << " dog is born.\n";
	};
	virtual void bark(std::string msg = "a dog") { std::cout << msg << " " << m_name << " is a dog.\n"; }
};

class yellowdog : public dog {
	std::string m_name;
public:
	yellowdog(std::string name) : m_name(name) {
		std::cout << m_name << " yellowdog is born.\n";
	};
	virtual void bark(std::string msg = "a yellowdog") { std::cout << msg << " " << m_name << " is a yellowdog.\n"; }
};

struct TreeNode {TreeNode *left, *right;};

class Generic_Parser {
   public:
   void parse_preorder(TreeNode* node) {
      if (node) {
         process_node(node);
         parse_preorder(node->left);
         parse_preorder(node->right);
      }
   }
   private:
   virtual void process_node(TreeNode* node) { }
};

class EmployeeChart_Parser : public Generic_Parser {
   private:
   void process_node(TreeNode* node) {
       std::cout << "Customized process_node() for EmployeeChart.\n";
   }
};

}

namespace Templates {
template<typename T> T aabs(T myNum) {
	if(myNum < 0) {
		return -myNum;
	}
	return myNum;
}

template<int ToAdd> class adder {
public:
	init doit(int x);
};


}

#endif /* INHERITED_H_ */
